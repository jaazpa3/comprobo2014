  This is a description of the file created for the class called Computational Robotics at Olin College. The file is a ROS platform-based Python script that controls the modified Neato robot to follow a wall and avoid obstacles.
	The program implements two main distinct behaviors, one go-straight behavior, one move-left behavior and a finite state machine that switches between the four behaviors. When the robot is run initially, the first behavior is to go straight. As soon as the robot has scanned for objects in front of it less than a foot away, the finite state machine will switch from the go-straight behavior to wall follow. 
  It will then adjust the angular direction of the robot determined by trigonometric calculations. To keep the robot parallel, we find the distance measurements from two congruent angles from 90 degrees, which is the direction to the left of the robot. Since we know the measured distance and the congruent angles in degrees, we can determine the angles between the angles from the lidar angles and the wall. The difference in degrees of the two angles from the wall indicate which angular direction the robot should take. Pairs of congruent degrees ranging from 0 to 45 degrees away from 90 degrees are calculated to create differences, which is then averaged. This average is then passed to a proportional and derivative control to adjust the robot’s angular velocity. The linear forward velocity is kept constant. If at any point in its wall following behavior the lidar detects something in a narrow range in front of it within a foot and that the robot is parallel to the wall, it will switch to the obstacle avoidance behavior.
  To avoid obstacles in front of the robot, it scans to find the angle of direction to avoid the furthest point of the obstacle from the wall. This information indicates how large or small the angular direction should be to avoid the obstacle. When it detects no objects in front of it, then the behavior will switch back from obstacle avoid to wall follow. Conveniently, the wall follow behavior allows the robot to move around the obstacle. When there are invalid lidar readings, the robot will move to the left, which is a behavior meant to find a wall. When the wall is found, the robot switches behavior back to wall follow and will switch its behavior if it detects an object.
  One of the challenges in this warm-up project was knowing how to structure my code. In the beginning, I was struggling with controlling my robot, because each method was publishing and subscribing to a node. This code structure was not very effective, because it meant that each method had to communicate between other methods. More importantly, the code became more complicated to understand and debug. Under frustration, I realized that I should re-write my code. I had dedicated one function to scan the robot’s surroundings and assign values to variables. My other functions would take in and interpret those values and control the robot.  In retrospect, I am incredibly glad that I had re-written my code structure in the beginning since I had later added layers of complexity to my code. For my future programming projects, I will plan my code structure before I write any code and make clean code. I believe that these measures will save time and frustration later in the project.
  If I had more time to work on the project, I would add functionality to follow and avoid obstacles on the right wall. I’m certain that this functionality would not be difficult to write, but given the nature of the warm-up project, to learn how to program the robot, I decided against adding that. 
	The robot also behaves erratically when it wall follows with objects in its scanning area. When wall following, incorrect lengths in direction are measured. As a result, from the trigonometric calculations, incorrect setpoints are determined. It would help to create a filter to ignore the measurements of objects near it while trying to wall follow.



